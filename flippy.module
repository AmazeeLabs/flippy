<?php
// Drupal classes used in this module
use Drupal\field\Field;
use Drupal\Core\Language\Language;

/**
 * @file
 * Allows administrators to add previous/next pagers to any node type.
 */

/**
 * Implements hook_theme()
 */
function flippy_theme() {
  return array(
    'flippy' => array(
      'variables' => array(
        'list' => array(),
      ),
      'template' => 'flippy',
    ),
  );
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function flippy_form_node_type_edit_form_alter(&$form, $form_state) {
  if (isset($form['type'])) {

    // flippy settings
    $flippy_node_type      = \Drupal::config('flippy.settings')->get('flippy_' . $form['type']['#default_value']);
    $flippy_head           = \Drupal::config('flippy.settings')->get('flippy_head_' . $form['type']['#default_value']);
    $flippy_show_empty     = \Drupal::config('flippy.settings')->get('flippy_show_empty_' . $form['type']['#default_value']);
    $flippy_prev_label     = \Drupal::config('flippy.settings')->get('flippy_prev_label_' . $form['type']['#default_value']);
    $flippy_next_label     = \Drupal::config('flippy.settings')->get('flippy_next_label_' . $form['type']['#default_value']);
    $flippy_first_last     = \Drupal::config('flippy.settings')->get('flippy_first_last_' . $form['type']['#default_value']);
    $flippy_first_label    = \Drupal::config('flippy.settings')->get('flippy_first_label_' . $form['type']['#default_value']);
    $flippy_last_label     = \Drupal::config('flippy.settings')->get('flippy_last_label_' . $form['type']['#default_value']);
    $flippy_loop           = \Drupal::config('flippy.settings')->get('flippy_loop_' . $form['type']['#default_value']);
    $flippy_random         = \Drupal::config('flippy.settings')->get('flippy_random_' . $form['type']['#default_value']);
    $flippy_random_label   = \Drupal::config('flippy.settings')->get('flippy_random_label' . $form['type']['#default_value']);
    $flippy_truncate       = \Drupal::config('flippy.settings')->get('flippy_truncate' . $form['type']['#default_value']);
    $flippy_ellipse        = \Drupal::config('flippy.settings')->get('flippy_ellipse' . $form['type']['#default_value']);
    $flippy_custom_sorting = \Drupal::config('flippy.settings')->get('flippy_custom_sorting' . $form['type']['#default_value']);
    $flippy_sort           = \Drupal::config('flippy.settings')->get('flippy_sort' . $form['type']['#default_value']);
    $flippy_order          = \Drupal::config('flippy.settings')->get('flippy_order' . $form['type']['#default_value']);

    $form['flippy'] = array(
      '#type' => 'details',
      '#title' => t('Flippy settings'),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#group' => 'additional_settings',
    );

    $form['flippy']['flippy'] = array(
      '#type' => 'checkbox',
      '#title' => t('Build a pager for this content type'),
      '#default_value' => isset($form['flippy']['flippy']) ? $form['flippy']['flippy'] : $flippy_node_type,
    );

    $form['flippy']['flippy_head'] = array(
      '#type' => 'checkbox',
      '#title' => t('Add semantic previous and next links to the document HEAD'),
      '#default_value' => isset($form['flippy']['flippy_head']) ? $form['flippy']['flippy_head'] : $flippy_head,
      '#states' => array(
        'visible' => array(   // action to take.
          ':input[name=flippy]' => array('checked' => TRUE),
        ),
      ),
    );

    $form['flippy']['flippy_show_empty'] = array(
      '#type' => 'checkbox',
      '#title' => t('Show empty links'),
      '#default_value' => isset($form['flippy']['flippy_show_empty']) ? $form['flippy']['flippy_show_empty'] : $flippy_show_empty,
      '#states' => array(
        'visible' => array(
          ':input[name=flippy]' => array('checked' => TRUE),
        ),
      ),
      '#description' => t('If checked, empty links will be rendered even if there isn\'t a node in the sequence. For example, if there is no "next" node, the "next" label will be shown but without a link. If tokens are being used, it is recommended that this be unchecked.'),
    );

    $form['flippy']['flippy_prev_label'] = array(
      '#type' => 'textfield',
      '#title' => t('Label for "Previous" link'),
      '#size' => 32,
      '#default_value' => isset($form['flippy']['flippy_prev_label']) ? $form['flippy']['flippy_prev_label'] : $flippy_prev_label,
      '#states' => array(
        'visible' => array(
          ':input[name=flippy]' => array('checked' => TRUE),
        ),
      ),
    );

    $form['flippy']['flippy_next_label'] = array(
      '#type' => 'textfield',
      '#title' => t('Label for "Next" link'),
      '#size' => 32,
      '#default_value' => isset($form['flippy']['flippy_next_label']) ? $form['flippy']['flippy_next_label'] : $flippy_next_label,
      '#states' => array(
        'visible' => array(
          ':input[name=flippy]' => array('checked' => TRUE),
        ),
      ),
    );

    $form['flippy']['flippy_firstlast'] = array(
      '#type' => 'checkbox',
      '#title' => t('Show first/last links'),
      '#default_value' => isset($form['flippy']['flippy_firstlast']) ? $form['flippy']['flippy_firstlast'] : $flippy_first_last,
      '#states' => array(
        'visible' => array(
          ':input[name=flippy]' => array('checked' => TRUE),
        ),
      ),
    );

    $form['flippy']['flippy_first_label'] = array(
      '#type' => 'textfield',
      '#title' => t('Label for "First" link'),
      '#size' => 32,
      '#default_value' => isset($form['flippy']['flippy_first_label']) ? $form['flippy']['flippy_first_label'] : $flippy_first_label,
      '#states' => array(
        'visible' => array(
          ':input[name=flippy_firstlast]' => array('checked' => TRUE),
          ':input[name=flippy]' => array('checked' => TRUE),

        ),
      ),
    );

    $form['flippy']['flippy_last_label'] = array(
      '#type' => 'textfield',
      '#title' => t('Label for "Last" link'),
      '#size' => 32,
      '#default_value' => isset($form['flippy']['flippy_last_label']) ? $form['flippy']['flippy_last_label'] : $flippy_last_label,
      '#states' => array(
        'visible' => array(
          ':input[name=flippy_firstlast]' => array('checked' => TRUE),
          ':input[name=flippy]' => array('checked' => TRUE),
        ),
      ),
    );

    $form['flippy']['flippy_loop'] = array(
      '#type' => 'checkbox',
      '#title' => t('Loop through nodes'),
      '#default_value' => isset($form['flippy']['flippy_loop']) ? $form['flippy']['flippy_loop'] : $flippy_loop,
      '#states' => array(
        'visible' => array(   // action to take.
          ':input[name=flippy]' => array('checked' => TRUE),
        ),
      ),
    );

    $form['flippy']['flippy_random'] = array(
      '#type' => 'checkbox',
      '#title' => t('Show random link'),
      '#default_value' => isset($form['flippy']['flippy_random']) ? $form['flippy']['flippy_random'] : $flippy_random,
      '#states' => array(
        'visible' => array(   // action to take.
          ':input[name=flippy]' => array('checked' => TRUE),
        ),
      ),
    );

    $form['flippy']['flippy_random_label'] = array(
      '#type' => 'textfield',
      '#title' => t('Label for "Random" link'),
      '#size' => 32,
      '#default_value' => isset($form['flippy']['flippy_random_label']) ? $form['flippy']['flippy_random_label'] : $flippy_random_label,
      '#states' => array(
        'visible' => array(
          ':input[name=flippy_random]' => array('checked' => TRUE),
          ':input[name=flippy]' => array('checked' => TRUE),
        ),
      ),
    );

    $form['flippy']['flippy_token'] = array(
      '#type' => 'fieldset',
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
      '#title' => t('Browse available tokens'),
      '#states' => array(
        'visible' => array(
          ':input[name=flippy]' => array('checked' => TRUE),
        ),
      ),
    );

    $form['flippy']['flippy_token']['flippy_token_browser'] = array(
      '#theme' => 'token_tree',
      '#token_types' => array('node'),
    );

    $form['flippy']['flippy_truncate'] = array(
      '#type' => 'textfield',
      '#title' => t('Truncate label length'),
      '#size' => 32,
      '#default_value' => isset($form['flippy']['flippy_truncate']) ? $form['flippy']['flippy_truncate'] : $flippy_truncate,
      '#description' => t('Optionally provide a maximum amount length that link labels can be. Labels will be shortened to this length if they exceed the amount of characters.'),
      '#states' => array(
        'visible' => array(
          ':input[name=flippy]' => array('checked' => TRUE),
        ),
      ),
    );

    $form['flippy']['flippy_ellipse'] = array(
      '#type' => 'textfield',
      '#title' => t('Truncate ellipse'),
      '#size' => 32,
      '#default_value' => isset($form['flippy']['flippy_ellipse']) ? $form['flippy']['flippy_ellipse'] : $flippy_ellipse,
      '#description' => t('If a maximum label length is set above, an ellipse can be provided here which will be appended to the label after it is shortened.'),
      '#states' => array(
        'visible' => array(
          ':input[name=flippy]' => array('checked' => TRUE),
        ),
      ),
    );

    $form['flippy']['flippy_custom_sorting'] = array(
      '#type' => 'checkbox',
      '#title' => t('Sort the pager by something other than ascending post date'),
      '#default_value' => isset($form['flippy']['flippy_custom_sorting']) ? $form['flippy']['flippy_custom_sorting'] : $flippy_custom_sorting,
      '#states' => array(
        'visible' => array(   // action to take.
          ':input[name=flippy]' => array('checked' => TRUE),
        ),
      ),
    );

    // Allow certain base table properties for sorting
    $sort_options = _flippy_sorting_properties();
    // Also allow some entity fields
    $field = new Field();
    $content_type_fields = $field::fieldInfo()->getBundleInstances('node', $form['type']['#default_value']);
    foreach ($content_type_fields as $sort_field) {
      $field_info = $field::fieldInfo()->getField('node', $sort_field->getFieldName());
      if ($field_info->status()) {
        // only allow fields that have a 'value' column
        $sort_options[$sort_field->getFieldName()] = $sort_field->label();
      }
    }

    $form['flippy']['flippy_sort'] = array(
      '#type' => 'select',
      '#title' => t('Pager sort'),
      '#options' => $sort_options,
      '#default_value' => isset($form['flippy']['flippy_sort']) ? $form['flippy']['flippy_sort'] : $flippy_sort,
      '#description' => t('Select a field for sorting the pager'),
      '#states' => array(
        'visible' => array(
          ':input[name=flippy_custom_sorting]' => array('checked' => TRUE),
        ),
      ),
    );

    $form['flippy']['flippy_order'] = array(
      '#type' => 'select',
      '#title' => t('Pager order'),
      '#options' => array('ASC' => 'Ascending', 'DESC' => 'Descending'),
      '#default_value' => isset($form['flippy']['flippy_order']) ? $form['flippy']['flippy_order'] : $flippy_order,
      '#description' => t('Select a direction to order the pager'),
      '#states' => array(
        'visible' => array(
          ':input[name=flippy_custom_sorting]' => array('checked' => TRUE),
        ),
      ),
    );

    // Add a custom submit handler to save the array of types back to the config
    // file.
    $form['actions']['submit']['#submit'][] = '_flippy_node_type_form_submit';
  }
}

/**
 * List the base node properties that are allowed for custom pager sorting.
 * These should all correspond to to columns in the node table.
 *
 * @return array Associative array of $machine_name => $human_name
 */
function _flippy_sorting_properties() {
  return array(
    'created' => t('Post date'),
    'title' => t('Title'),
    'nid' => t('Node ID'),
  );
}

/**
 * Creating custom form submit handler to save the settings to config file.
 */
function _flippy_node_type_form_submit($form, $form_state) {
  \Drupal::config('flippy.settings')
    ->set('flippy_' . $form['type']['#default_value'], $form_state['values']['flippy'])
    ->set('flippy_head_' . $form['type']['#default_value'], $form_state['values']['flippy_head'])
    ->set('flippy_show_empty_' . $form['type']['#default_value'], $form_state['values']['flippy_show_empty'])
    ->set('flippy_prev_label_' . $form['type']['#default_value'], $form_state['values']['flippy_prev_label'])
    ->set('flippy_next_label_' . $form['type']['#default_value'], $form_state['values']['flippy_next_label'])
    ->set('flippy_first_last_' . $form['type']['#default_value'], $form_state['values']['flippy_firstlast'])
    ->set('flippy_first_label_' . $form['type']['#default_value'], $form_state['values']['flippy_first_label'])
    ->set('flippy_last_label_' . $form['type']['#default_value'], $form_state['values']['flippy_last_label'])
    ->set('flippy_loop_' . $form['type']['#default_value'], $form_state['values']['flippy_loop'])
    ->set('flippy_random_' . $form['type']['#default_value'], $form_state['values']['flippy_random'])
    ->set('flippy_random_label_' . $form['type']['#default_value'], $form_state['values']['flippy_random_label'])
    ->set('flippy_truncate_' . $form['type']['#default_value'], $form_state['values']['flippy_truncate'])
    ->set('flippy_ellipse' . $form['type']['#default_value'], $form_state['values']['flippy_ellipse'])
    ->set('flippy_custom_sorting_' . $form['type']['#default_value'], $form_state['values']['flippy_custom_sorting'])
    ->set('flippy_sort_' . $form['type']['#default_value'], $form_state['values']['flippy_sort'])
    ->set('flippy_order_' . $form['type']['#default_value'], $form_state['values']['flippy_order'])
    ->save();
}

/**
 * Implements hook_field_extra_fields().
 */
function flippy_field_extra_fields() {
  $extra = array();
  foreach (node_type_get_names() as $type => $name) {
    $flippy_node_type = \Drupal::config('flippy.settings')->get('flippy_' . $type);
    if ($flippy_node_type) {
      $extra['node'][$type] = array(
        'display' => array(
          'flippy_pager' => array(
            'label' => t('Pager'),
            'description' => t('Flippy module content pager.'),
            'weight' => 5,
          ),
        ),
      );
    }
  }
  return $extra;
}

/**
 * Implements hook_node_view().
 */
function flippy_node_view($node, $view_mode = 'full') {
  // Only add the pager if it should be used for this node's content type.
  if (_flippy_use_pager($node)) {
    $node->content['flippy_pager'] = array(
      '#theme' => 'flippy',
      '#list' => flippy_build_list($node),
    );
    // Add the previous/next elements to the page head, if enable for this
    // content type.
    _flippy_add_head_elements($node);
  }
}

/**
 *  Function that builds the list of nodes
 */
function flippy_build_list($node) {
  $master_list = &drupal_static(__FUNCTION__);
  if (!isset($master_list)) {
    $master_list = array();
  }
  if (!isset($master_list[$node->id()])) {
    // Check to see if we need custom sorting
    if (\Drupal::config('flippy.settings')->get('flippy_custom_sorting_' . $node->getType())) {
      // Get order
      $order = \Drupal::config('flippy.settings')->get('flippy_order_' . $node->getType());
      // Get sort
      $sort = \Drupal::config('flippy.settings')->get('flippy_sort_' . $node->getType());
    }
    else {
      $order = 'ASC';
      $sort = 'created';
    }
    // Validate that the sort criteria is OK to use
    $base_table_properties = array_keys(_flippy_sorting_properties());
    $field_value = NULL;
    // If the sort criteria is not in the base_table_properties array,
    // we assume it's a field
    if (!in_array($sort, $base_table_properties)) {
      // get the value of the current node's field (use the first one only)
      $current_field_items = $node->getTranslation(NULL)->{$sort};
      if (!isset($current_field_items[0]['value'])) {
        // should never happen, but just in case, fall back to post date ascending
        $sort  = 'created';
        $order = 'ASC';
      }
      else {
        // Otherwise save the field value for later
        $field_value = $current_field_items[0]['value'];
      }
    }
    // Depending on order, decide what before and after means
    $before = ($order == 'ASC') ? '<' : '>';
    $after  = ($order == 'ASC') ? '>' : '<';
    // Also decide what up and down means
    $up   = ($order == 'ASC') ? 'ASC' : 'DESC';
    $down = ($order == 'ASC') ? 'DESC' : 'ASC';
    // Create a starting-point EntityQuery object
    //$language = new Language();
    $query = \Drupal::entityQuery('node');
    $query->condition('type', $node->getType())
      ->condition('status', 1)
      ->condition('nid', $node->id(), '!=')
      //->condition('langcode', array($language::LANGCODE_DEFAULT, $language::LANGCODE_NOT_SPECIFIED), 'IN')
      ->range(0, 1)
      ->addTag('node_access');
    // Create the individual queries
    $first  = clone $query;
    $prev   = clone $query;
    $next   = clone $query;
    $last   = clone $query;
    $random = clone $query;
    // We will construct the queries differently depending on whether the sorting
    // criteria is a field or a base table property.
    // If we found a field value earlier, we know we're dealing with a field
    if ($field_value) {
      // set the conditions
      $first->condition($sort . 'value', $field_value, $before);
      $prev->condition($sort . 'value', $field_value, $before);
      $next->condition($sort . 'value', $field_value, $after);
      $last->condition($sort . 'value', $field_value, $after);
      // set the ordering
      $first->sort($sort, $up);
      $prev->sort($sort, $down);
      $next->sort($sort, $up);
      $last->sort($sort, $down);
    }
    else {
      // Otherwise we assume the variable is a column in the base table
      // (a property). Like above, set the conditions
      $propertyValues = $node->getPropertyValues();
      $first->condition($sort, $propertyValues[$sort][0]['value'], $before);
      $prev->condition($sort, $propertyValues[$sort][0]['value'], $before);
      $next->condition($sort, $propertyValues[$sort][0]['value'], $after);
      $last->condition($sort, $propertyValues[$sort][0]['value'], $after);
      // set the ordering
      $first->sort($sort, $up);
      $prev->sort($sort, $down);
      $next->sort($sort, $up);
      $last->sort($sort, $down);
    }
    // Execute the queries
    $results = array();
    $results['first'] = $first->execute();
    $results['prev']  = $prev->execute();
    $results['next']  = $next->execute();
    $results['last']  = $last->execute();

    $node_ids = array();
    foreach ($results as $key => $result) {
      // if the query returned no results, it means we're already
      // at the beginning/end of the pager, so ignore those
      if (count($result) > 0) {
        // otherwise we save the node ID
        $result_nids = array_keys($results[$key]);
        $node_ids[$key] = $result_nids[0];
      }
    }
    // make our final array of node IDs and titles
    $list = array();
    // but only if we actually found some matches
    if (count($node_ids) > 0) {
      // we also need titles to go with our node ids
      $title_query = db_select('node_field_data', 'n')
        ->fields('n', array('title', 'nid'))
        ->condition('n.nid', $node_ids, 'IN')
        ->execute()
        ->fetchAllAssoc('nid');

      foreach ($node_ids as $key => $nid) {
        $list[$key] = array(
          'nid' => $nid,
          'title' => $title_query[$nid]->title,
        );
      }
    }
    // create random list
    if (\Drupal::config('flippy.settings')->get('flippy_random_' . $node->getType())) {

      $random->addTag('random');
      $result = $random->execute();

      if (isset($result)) {
        $nids = array_keys($result);
        foreach($nids as $nid) {
          $node = node_load($nid);
          $title = $node->title;
          $list['random'] = array(
            'nid' => $nid,
            'title' => $title,
          );
        }
      }

    }
    // finally set the current info for themers to use

    $list['current'] = array(
      'nid' => $node->id(),
      'title' => $node->getTitle(),
    );

    $master_list[$node->id()] = $list;
  }
  return $master_list[$node->id()];
}

/**
 * Implement hook_query_TAG_alter()
 */
function flippy_query_random_alter($query){
  $query->orderRandom();
}

/**
 *  Implements template_preprocess_hook()
 */
function template_preprocess_flippy(&$vars) {
  drupal_add_css(drupal_get_path('module', 'flippy') . '/flippy.css');

  // for getting node type
  if ($node = menu_get_object('node')) {
    $vars['node'] = $node;
  }

  // Get all the labels
  $first_label  = \Drupal::config('flippy.settings')->get('flippy_first_label_' . $vars['node']->getType());
  $last_label   = \Drupal::config('flippy.settings')->get('flippy_last_label_' . $vars['node']->getType());
  $random_label = \Drupal::config('flippy.settings')->get('flippy_random_label_' . $vars['node']->getType());
  $prev_label   = \Drupal::config('flippy.settings')->get('flippy_prev_label_' . $vars['node']->getType());
  $next_label   = \Drupal::config('flippy.settings')->get('flippy_next_label_' . $vars['node']->getType());

  $show_empty = \Drupal::config('flippy.settings')->get('flippy_show_empty_' . $vars['node']->getType());

  // See if we need to truncate labels
  if ($truncate = \Drupal::config('flippy.settings')->get('flippy_truncate_' . $vars['node']->getType())) {
    if (is_numeric($truncate)) {
      $first_label  = strlen($first_label) > $truncate ? $first_label : substr($first_label, 0, $truncate) . \Drupal::config('flippy.settings').get('flippy_ellipse_' . $vars['node']->getType());
      $last_label   = strlen($last_label) > $truncate ? $last_label : substr($last_label, 0, $truncate) . \Drupal::config('flippy.settings').get('flippy_ellipse_' . $vars['node']->getType());
      $random_label = strlen($random_label) > $truncate ? $random_label : substr($random_label, 0, $truncate) . \Drupal::config('flippy.settings').get('flippy_ellipse_' . $vars['node']->getType());
      $prev_label   = strlen($prev_label) > $truncate ? $prev_label : substr($prev_label, 0, $truncate) . \Drupal::config('flippy.settings').get('flippy_ellipse_' . $vars['node']->getType());
      $next_label   = strlen($next_label) > $truncate ? $next_label : substr($next_label, 0, $truncate) . \Drupal::config('flippy.settings').get('flippy_ellipse_' . $vars['node']->getType());
    }
  }

  // See if we need to create the loop
  if (\Drupal::config('flippy.settings')->get('flippy_loop_'. $vars['node']->getType())) {
    if (!isset($vars['list']['last']['nid'])) {
      $vars['list']['next']['nid'] = $vars['list']['first']['nid'];
    }
    if (!isset($vars['list']['first']['nid'])) {
      $vars['list']['prev']['nid'] = $vars['list']['last']['nid'];
    }
  }

  // Build the variables for twig
  if ($nav = $vars['list']) {
    if (\Drupal::config('flippy.settings')->get('flippy_first_last_' . $vars['node']->getType()) != NULL) {
      if (isset($nav['first'])) {
        $vars['first'] = l($first_label, 'node/' . $nav['first']['nid']);
      }
      elseif ($show_empty) {
        $vars['first'] = $first_label;
      }

      if (isset($nav['last'])) {
        $vars['last'] = l($last_label, 'node/' . $nav['last']['nid']);
      }
      elseif ($show_empty) {
        $vars['last'] = $last_label;
      }
    }

    if (\Drupal::config('flippy.settings')->get('flippy_random_'. $vars['node']->getType())) {
      $vars['random'] = l($random_label, 'node/' . $nav['random']['nid']);
    }
    else {
      $vars['random'] = '';
    }

    if ($nav['prev']) {
      $vars['prev'] = l($prev_label, 'node/' . $nav['prev']['nid']);
    }
    elseif ($show_empty) {
      $vars['prev'] = t($prev_label);
    }

    if ($nav['next']) {
      $vars['next'] = l($next_label, 'node/' . $nav['next']['nid']);
    }
    elseif ($show_empty) {
      $vars['next'] = t($next_label);
    }
  }

  // Replace any tokens present in the links
  // todo add token replace when token d8 is available.
  //foreach ($links as $key => &$link) {
  //  if (isset($nav[$key]['nid']) && $nav[$key]['nid']) {
  //    if (isset($list_nodes[$nav[$key]['nid']])) {
  //      $link['title'] = token_replace($link['title'], array('node' => $list_nodes[$nav[$key]['nid']]));
  //    }
  //  }
  //}

  unset($vars['list']);
  unset($vars['node']);
}

/**
 * Determine if the Flippy pager should be shown for the give node.
 *
 * @param $node
 *   Node to check for pager
 *
 * @return bool Boolean: TRUE if pager should be shown, FALSE if not
 */
function _flippy_use_pager($node) {
  if (!is_object($node)) {
    return FALSE;
  }
  return node_is_page($node) && \Drupal::config('flippy.settings')->get('flippy_' . $node->getType());
}

/**
 * Add the previous/next elements to the page head, if enable for the content
 * type of the given node.
 *
 * @param $node
 *   Node to add head elements for
 */
function _flippy_add_head_elements($node) {
  if (is_object($node)) {
    if (\Drupal::config('flippy.settings')->get('flippy_head_' . $node->getType())) {
      $links = flippy_build_list($node);
      if (!empty($links['prev'])) {
        drupal_add_html_head_link(array(
          'rel' => 'prev',
          'href' => url('node/' . $links['prev']['nid']),
        ));
      }
      if (!empty($links['next'])) {
        drupal_add_html_head_link(array(
          'rel' => 'next',
          'href' => url('node/' . $links['next']['nid']),
        ));
      }
    }
  }
}
